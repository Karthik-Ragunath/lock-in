<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lock-In Audio Client</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface-2: #252836;
    --border: #2e3245;
    --text: #e4e6f0;
    --text-dim: #8b8fa3;
    --accent: #6c5ce7;
    --accent-glow: rgba(108, 92, 231, 0.3);
    --green: #00b894;
    --red: #e17055;
    --orange: #fdcb6e;
    --radius: 10px;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem;
  }

  h1 {
    font-size: 1.5rem;
    font-weight: 600;
    letter-spacing: -0.02em;
    margin-bottom: 0.25rem;
  }

  .subtitle { color: var(--text-dim); font-size: 0.85rem; margin-bottom: 2rem; }

  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 1.25rem;
    width: 100%;
    max-width: 480px;
    margin-bottom: 1rem;
  }

  .card-title {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-dim);
    margin-bottom: 0.75rem;
  }

  .row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  input[type="text"] {
    flex: 1;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.55rem 0.75rem;
    color: var(--text);
    font-size: 0.9rem;
    font-family: 'SF Mono', 'Fira Code', monospace;
    outline: none;
    transition: border-color 0.15s;
  }

  input[type="text"]:focus { border-color: var(--accent); }

  button {
    padding: 0.55rem 1.1rem;
    border-radius: 6px;
    border: none;
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .btn-connect {
    background: var(--accent);
    color: #fff;
  }
  .btn-connect:hover { filter: brightness(1.15); }
  .btn-connect:disabled { opacity: 0.5; cursor: not-allowed; }

  .btn-disconnect {
    background: var(--red);
    color: #fff;
  }
  .btn-disconnect:hover { filter: brightness(1.15); }

  .btn-mic {
    width: 100%;
    padding: 0.7rem;
    font-size: 0.9rem;
    background: var(--surface-2);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-mic:hover { border-color: var(--accent); }
  .btn-mic.active {
    background: rgba(0, 184, 148, 0.15);
    border-color: var(--green);
    color: var(--green);
  }
  .btn-mic:disabled { opacity: 0.4; cursor: not-allowed; }

  .status-bar {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.75rem;
    font-size: 0.8rem;
    color: var(--text-dim);
  }

  .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
    flex-shrink: 0;
  }
  .dot.connected { background: var(--green); box-shadow: 0 0 6px var(--green); }
  .dot.error { background: var(--red); }

  .log-area {
    background: var(--surface-2);
    border-radius: 6px;
    padding: 0.75rem;
    max-height: 260px;
    overflow-y: auto;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.75rem;
    line-height: 1.6;
    color: var(--text-dim);
  }

  .log-area .info { color: var(--text); }
  .log-area .success { color: var(--green); }
  .log-area .warn { color: var(--orange); }
  .log-area .error { color: var(--red); }
  .log-area .audio { color: var(--accent); }

  .meter-wrap {
    margin-top: 0.75rem;
  }

  .meter-label {
    font-size: 0.7rem;
    color: var(--text-dim);
    margin-bottom: 0.25rem;
  }

  .meter {
    height: 4px;
    background: var(--surface-2);
    border-radius: 2px;
    overflow: hidden;
  }

  .meter-fill {
    height: 100%;
    width: 0%;
    background: var(--accent);
    border-radius: 2px;
    transition: width 0.05s;
  }

  .meter-fill.mic { background: var(--green); }
</style>
</head>
<body>
  <h1>Lock-In Audio Client</h1>
  <p class="subtitle">Connect to the voice agent's audio pipeline</p>

  <div class="card">
    <div class="card-title">Connection</div>
    <div class="row">
      <input type="text" id="wsUrl" value="ws://localhost:8765" spellcheck="false" />
      <button class="btn-connect" id="btnConnect" onclick="toggleConnection()">Connect</button>
    </div>
    <div class="status-bar">
      <span class="dot" id="statusDot"></span>
      <span id="statusText">Disconnected</span>
    </div>
  </div>

  <div class="card">
    <div class="card-title">Microphone</div>
    <button class="btn-mic" id="btnMic" disabled onclick="toggleMic()">Enable Microphone</button>
    <div class="meter-wrap">
      <div class="meter-label">Mic level</div>
      <div class="meter"><div class="meter-fill mic" id="micMeter"></div></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">Speaker</div>
    <div class="meter-wrap" style="margin-top:0">
      <div class="meter-label">Audio output level</div>
      <div class="meter"><div class="meter-fill" id="spkMeter"></div></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">Log</div>
    <div class="log-area" id="logArea"></div>
  </div>

<script>
// ---------- Protobuf codec (hand-rolled, matching pipecat's frames.proto) ----------
// Wire format:
//   Frame { oneof frame { TextFrame text=1; AudioRawFrame audio=2; TranscriptionFrame transcription=3; MessageFrame message=4; } }
//   AudioRawFrame { uint64 id=1; string name=2; bytes audio=3; uint32 sample_rate=4; uint32 num_channels=5; optional uint64 pts=6; }

const Protobuf = (() => {
  function encodeVarint(n) {
    const bytes = [];
    n = BigInt(n);
    while (n > 0x7fn) {
      bytes.push(Number(n & 0x7fn) | 0x80);
      n >>= 7n;
    }
    bytes.push(Number(n));
    return new Uint8Array(bytes);
  }

  function encodeTag(fieldNumber, wireType) {
    return encodeVarint((fieldNumber << 3) | wireType);
  }

  function encodeLengthDelimited(fieldNumber, data) {
    const tag = encodeTag(fieldNumber, 2);
    const len = encodeVarint(data.byteLength);
    const result = new Uint8Array(tag.length + len.length + data.byteLength);
    result.set(tag, 0);
    result.set(len, tag.length);
    result.set(new Uint8Array(data.buffer || data), tag.length + len.length);
    return result;
  }

  function encodeUint32Field(fieldNumber, value) {
    if (!value) return new Uint8Array(0);
    const tag = encodeTag(fieldNumber, 0);
    const val = encodeVarint(value);
    const result = new Uint8Array(tag.length + val.length);
    result.set(tag, 0);
    result.set(val, tag.length);
    return result;
  }

  function concat(...arrays) {
    arrays = arrays.filter(a => a.length > 0);
    const total = arrays.reduce((s, a) => s + a.length, 0);
    const result = new Uint8Array(total);
    let offset = 0;
    for (const a of arrays) {
      result.set(a, offset);
      offset += a.length;
    }
    return result;
  }

  function encodeAudioRawFrame(pcmBytes, sampleRate, numChannels) {
    const audioField = encodeLengthDelimited(3, pcmBytes);
    const srField = encodeUint32Field(4, sampleRate);
    const chField = encodeUint32Field(5, numChannels);
    const innerMsg = concat(audioField, srField, chField);
    return encodeLengthDelimited(2, innerMsg);
  }

  // --- Decoder ---
  function decodeVarint(buf, offset) {
    let result = 0n;
    let shift = 0n;
    let i = offset;
    while (i < buf.length) {
      const b = BigInt(buf[i]);
      result |= (b & 0x7fn) << shift;
      i++;
      if ((b & 0x80n) === 0n) break;
      shift += 7n;
    }
    return [result, i];
  }

  function decodeFrame(data) {
    const buf = new Uint8Array(data);
    let pos = 0;
    let audioData = null;
    let sampleRate = 0;
    let numChannels = 1;
    let textContent = null;
    let transcriptionText = null;
    let frameType = null;

    while (pos < buf.length) {
      const [tagVal, newPos] = decodeVarint(buf, pos);
      pos = newPos;
      const fieldNumber = Number(tagVal >> 3n);
      const wireType = Number(tagVal & 0x7n);

      if (wireType === 2) {
        const [len, dataStart] = decodeVarint(buf, pos);
        pos = dataStart;
        const fieldData = buf.slice(pos, pos + Number(len));
        pos += Number(len);

        if (fieldNumber === 1) {
          frameType = 'text';
          textContent = decodeTextField(fieldData);
        } else if (fieldNumber === 2) {
          frameType = 'audio';
          const parsed = decodeAudioFields(fieldData);
          audioData = parsed.audio;
          sampleRate = parsed.sampleRate;
          numChannels = parsed.numChannels;
        } else if (fieldNumber === 3) {
          frameType = 'transcription';
          transcriptionText = decodeTextField(fieldData);
        }
      } else if (wireType === 0) {
        const [_, skipPos] = decodeVarint(buf, pos);
        pos = skipPos;
      }
    }

    return { frameType, audioData, sampleRate, numChannels, textContent, transcriptionText };
  }

  function decodeAudioFields(buf) {
    let audio = null, sampleRate = 0, numChannels = 1;
    let pos = 0;
    while (pos < buf.length) {
      const [tagVal, newPos] = decodeVarint(buf, pos);
      pos = newPos;
      const fn = Number(tagVal >> 3n);
      const wt = Number(tagVal & 0x7n);

      if (wt === 2) {
        const [len, ds] = decodeVarint(buf, pos);
        pos = ds;
        if (fn === 3) audio = buf.slice(pos, pos + Number(len));
        pos += Number(len);
      } else if (wt === 0) {
        const [val, np] = decodeVarint(buf, pos);
        pos = np;
        if (fn === 4) sampleRate = Number(val);
        if (fn === 5) numChannels = Number(val);
      }
    }
    return { audio, sampleRate, numChannels };
  }

  function decodeTextField(buf) {
    let pos = 0, text = '';
    while (pos < buf.length) {
      const [tagVal, newPos] = decodeVarint(buf, pos);
      pos = newPos;
      const fn = Number(tagVal >> 3n);
      const wt = Number(tagVal & 0x7n);
      if (wt === 2) {
        const [len, ds] = decodeVarint(buf, pos);
        pos = ds;
        if (fn === 3) text = new TextDecoder().decode(buf.slice(pos, pos + Number(len)));
        pos += Number(len);
      } else if (wt === 0) {
        const [_, np] = decodeVarint(buf, pos);
        pos = np;
      }
    }
    return text;
  }

  return { encodeAudioRawFrame, decodeFrame };
})();


// ---------- State ----------
let ws = null;
let audioCtx = null;
let micStream = null;
let micProcessor = null;
let micSource = null;
let micAnalyser = null;
let spkAnalyser = null;
let isConnected = false;
let isMicActive = false;
let playbackQueue = [];
let isPlaying = false;

const PLAYBACK_SAMPLE_RATE = 24000;
const MIC_SAMPLE_RATE = 16000;

const $wsUrl = document.getElementById('wsUrl');
const $btnConnect = document.getElementById('btnConnect');
const $btnMic = document.getElementById('btnMic');
const $statusDot = document.getElementById('statusDot');
const $statusText = document.getElementById('statusText');
const $logArea = document.getElementById('logArea');
const $micMeter = document.getElementById('micMeter');
const $spkMeter = document.getElementById('spkMeter');


// ---------- Logging ----------
function log(msg, cls = 'info') {
  const line = document.createElement('div');
  line.className = cls;
  const ts = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  line.textContent = `[${ts}] ${msg}`;
  $logArea.appendChild(line);
  $logArea.scrollTop = $logArea.scrollHeight;
}


// ---------- Connection ----------
function setStatus(connected, text) {
  isConnected = connected;
  $statusDot.className = 'dot' + (connected ? ' connected' : '');
  $statusText.textContent = text;
  $btnConnect.textContent = connected ? 'Disconnect' : 'Connect';
  $btnConnect.className = connected ? 'btn-disconnect' : 'btn-connect';
  $btnMic.disabled = !connected;
  if (!connected && isMicActive) stopMic();
}

function toggleConnection() {
  if (isConnected) {
    disconnect();
  } else {
    connect();
  }
}

async function connect() {
  const url = $wsUrl.value.trim();
  if (!url) return;

  $btnConnect.disabled = true;
  setStatus(false, 'Connecting...');
  log(`Connecting to ${url}...`);

  try {
    audioCtx = new AudioContext({ sampleRate: PLAYBACK_SAMPLE_RATE });
    spkAnalyser = audioCtx.createAnalyser();
    spkAnalyser.fftSize = 256;
    spkAnalyser.connect(audioCtx.destination);

    ws = new WebSocket(url);
    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
      setStatus(true, 'Connected');
      log('Connected to voice agent', 'success');
      $btnConnect.disabled = false;
    };

    ws.onmessage = (event) => {
      handleMessage(event.data);
    };

    ws.onclose = (event) => {
      setStatus(false, 'Disconnected');
      log(`Connection closed (code: ${event.code})`, 'warn');
      $btnConnect.disabled = false;
      cleanup();
    };

    ws.onerror = () => {
      setStatus(false, 'Connection error');
      $statusDot.className = 'dot error';
      log('WebSocket error', 'error');
      $btnConnect.disabled = false;
    };

  } catch (e) {
    log(`Connect error: ${e.message}`, 'error');
    $btnConnect.disabled = false;
    setStatus(false, 'Disconnected');
  }
}

function disconnect() {
  log('Disconnecting...');
  if (ws) ws.close();
  cleanup();
  setStatus(false, 'Disconnected');
}

function cleanup() {
  stopMic();
  playbackQueue = [];
  isPlaying = false;
  if (audioCtx && audioCtx.state !== 'closed') {
    audioCtx.close().catch(() => {});
  }
  audioCtx = null;
  spkAnalyser = null;
  ws = null;
}


// ---------- Incoming Messages ----------
let audioFrameCount = 0;

function handleMessage(data) {
  if (typeof data === 'string') {
    log(`Text message: ${data}`);
    return;
  }

  try {
    const frame = Protobuf.decodeFrame(data);

    if (frame.frameType === 'audio' && frame.audioData) {
      audioFrameCount++;
      if (audioFrameCount <= 3 || audioFrameCount % 50 === 0) {
        log(`Audio frame #${audioFrameCount}: ${frame.audioData.length}B @ ${frame.sampleRate}Hz`, 'audio');
      }
      queueAudio(frame.audioData, frame.sampleRate || PLAYBACK_SAMPLE_RATE, frame.numChannels || 1);
    } else if (frame.frameType === 'text' && frame.textContent) {
      log(`TTS text: "${frame.textContent}"`, 'info');
    } else if (frame.frameType === 'transcription' && frame.transcriptionText) {
      log(`STT: "${frame.transcriptionText}"`, 'success');
    }
  } catch (e) {
    log(`Decode error: ${e.message}`, 'error');
  }
}


// ---------- Audio Playback ----------
function queueAudio(pcmBytes, sampleRate, numChannels) {
  if (!audioCtx) return;

  const int16 = new Int16Array(pcmBytes.buffer, pcmBytes.byteOffset, pcmBytes.byteLength / 2);
  const float32 = new Float32Array(int16.length);
  for (let i = 0; i < int16.length; i++) {
    float32[i] = int16[i] / 32768.0;
  }

  const numFrames = float32.length / numChannels;
  const buffer = audioCtx.createBuffer(numChannels, numFrames, sampleRate);
  buffer.getChannelData(0).set(float32.subarray(0, numFrames));

  playbackQueue.push(buffer);
  if (!isPlaying) drainPlaybackQueue();
}

let nextPlayTime = 0;

function drainPlaybackQueue() {
  if (!audioCtx || playbackQueue.length === 0) {
    isPlaying = false;
    return;
  }

  isPlaying = true;
  const buffer = playbackQueue.shift();
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(spkAnalyser);

  const now = audioCtx.currentTime;
  const startTime = Math.max(now, nextPlayTime);
  source.start(startTime);
  nextPlayTime = startTime + buffer.duration;

  source.onended = () => {
    drainPlaybackQueue();
  };
}


// ---------- Microphone ----------
function toggleMic() {
  if (isMicActive) {
    stopMic();
  } else {
    startMic();
  }
}

async function startMic() {
  if (!audioCtx || !ws) return;

  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    log('Microphone requires HTTPS or localhost. Audio playback still works.', 'warn');
    return;
  }

  try {
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { sampleRate: MIC_SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true }
    });

    const micCtx = new AudioContext({ sampleRate: MIC_SAMPLE_RATE });
    micSource = micCtx.createMediaStreamSource(micStream);
    micAnalyser = micCtx.createAnalyser();
    micAnalyser.fftSize = 256;
    micSource.connect(micAnalyser);

    const bufferSize = 4096;
    micProcessor = micCtx.createScriptProcessor(bufferSize, 1, 1);
    micAnalyser.connect(micProcessor);
    micProcessor.connect(micCtx.destination);

    micProcessor.onaudioprocess = (e) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      const float32 = e.inputBuffer.getChannelData(0);
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        const s = Math.max(-1, Math.min(1, float32[i]));
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
      }

      const pcmBytes = new Uint8Array(int16.buffer);
      const frame = Protobuf.encodeAudioRawFrame(pcmBytes, MIC_SAMPLE_RATE, 1);
      ws.send(frame.buffer);
    };

    micProcessor._micCtx = micCtx;

    isMicActive = true;
    $btnMic.textContent = 'Disable Microphone';
    $btnMic.classList.add('active');
    log('Microphone enabled', 'success');

  } catch (e) {
    log(`Mic error: ${e.message}`, 'error');
  }
}

function stopMic() {
  if (micProcessor) {
    micProcessor.disconnect();
    if (micProcessor._micCtx) micProcessor._micCtx.close().catch(() => {});
    micProcessor = null;
  }
  if (micSource) { micSource.disconnect(); micSource = null; }
  if (micStream) {
    micStream.getTracks().forEach(t => t.stop());
    micStream = null;
  }
  micAnalyser = null;
  isMicActive = false;
  $btnMic.textContent = 'Enable Microphone';
  $btnMic.classList.remove('active');
  $micMeter.style.width = '0%';
}


// ---------- Meters ----------
function updateMeters() {
  if (micAnalyser) {
    const data = new Uint8Array(micAnalyser.frequencyBinCount);
    micAnalyser.getByteFrequencyData(data);
    const avg = data.reduce((a, b) => a + b, 0) / data.length;
    $micMeter.style.width = Math.min(100, avg / 128 * 100) + '%';
  }

  if (spkAnalyser) {
    const data = new Uint8Array(spkAnalyser.frequencyBinCount);
    spkAnalyser.getByteFrequencyData(data);
    const avg = data.reduce((a, b) => a + b, 0) / data.length;
    $spkMeter.style.width = Math.min(100, avg / 128 * 100) + '%';
  }

  requestAnimationFrame(updateMeters);
}

updateMeters();

// Set default URL based on page location
if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
  $wsUrl.value = `ws://${location.hostname}:8765`;
}

log('Ready. Enter WebSocket URL and click Connect.');
</script>
</body>
</html>
